main : 

import pandas as pd
import gradio as gr
from collections import defaultdict

# Helper functions
def extract_algo_keys(df):
    return df['Agreement_name'].astype(str).apply(
        lambda x: x.replace('_RIMR', '3CR')
                  .replace('_RIMP', '3CP')
                  .replace(" ", "")
                  .strip()
    ).tolist()

def extract_star_keys(df):
    return df.apply(
        lambda row: (str(row.get('CRDS Party Code', '')).strip().replace(" ", "") +
                     "3" +
                     str(row.get('Post Direction', '')).strip().replace(" ", "")),
        axis=1
    ).tolist()

# Loaders
def load_algo_file(file):
    try:
        df = pd.read_csv(file).astype(str)
        return df, gr.update(choices=list(df.columns))
    except Exception as e:
        return pd.DataFrame(), gr.update(choices=[])

def load_star_file(file):
    try:
        df = pd.read_csv(file).astype(str)
        return df, gr.update(choices=list(df.columns))
    except Exception as e:
        return pd.DataFrame(), gr.update(choices=[])

# Column dropdown update
def update_column_dropdown(file_type, algo_df, star_df):
    if file_type == "ALGO":
        return gr.update(choices=list(algo_df.columns))
    elif file_type == "STAR":
        return gr.update(choices=list(star_df.columns))
    return gr.update(choices=[])

# Reconciliation logic
def reconcile_with_exclusion(algo_df, star_df, file_type, column, operator, value):
    df_algo = algo_df.copy()
    df_star = star_df.copy()
    excluded_df = pd.DataFrame()

    values = [v.strip() for v in value.split(',') if v.strip()]

    if file_type == "ALGO" and column in df_algo.columns:
        if operator == "=":
            excluded_df = df_algo[df_algo[column].isin(values)]
            df_algo = df_algo[~df_algo[column].isin(values)]
        else:
            excluded_df = df_algo[~df_algo[column].isin(values)]
            df_algo = df_algo[df_algo[column].isin(values)]

    elif file_type == "STAR" and column in df_star.columns:
        if operator == "=":
            excluded_df = df_star[df_star[column].isin(values)]
            df_star = df_star[~df_star[column].isin(values)]
        else:
            excluded_df = df_star[~df_star[column].isin(values)]
            df_star = df_star[df_star[column].isin(values)]

    algo_keys = extract_algo_keys(df_algo)
    star_keys = extract_star_keys(df_star)

    matched = []
    unmatched = []

    star_key_map = defaultdict(list)
    for idx, key in enumerate(star_keys):
        star_key_map[key].append(idx)

    matched_star_indices = set()
    matched_algo_indices = set()
    star_key_used_count = defaultdict(int)

    for i, algo_key in enumerate(algo_keys):
        matching_star_idxs = star_key_map.get(algo_key, [])
        if len(matching_star_idxs) == 1 and matching_star_idxs[0] not in matched_star_indices:
            matched.append({
                "ALGO Key": algo_key,
                "STAR Key": star_keys[matching_star_idxs[0]],
                "Status": "Match"
            })
            matched_star_indices.add(matching_star_idxs[0])
            matched_algo_indices.add(i)
            star_key_used_count[star_keys[matching_star_idxs[0]]] += 1
        elif len(matching_star_idxs) > 1:
            unmatched.append({
                "ALGO Key": algo_key,
                "STAR Key": "<Multiple STAR Match>",
                "Status": "Mismatch - Multiple STAR Keys"
            })
            for idx in matching_star_idxs:
                unmatched.append({
                    "ALGO Key": "<No Match>",
                    "STAR Key": star_keys[idx],
                    "Status": "Mismatch - STAR Key in Multiple Match"
                })
            matched_algo_indices.add(i)
            for idx in matching_star_idxs:
                star_key_used_count[star_keys[idx]] += 1
        else:
            unmatched.append({
                "ALGO Key": algo_key,
                "STAR Key": "<No Match>",
                "Status": "Mismatch - No STAR Match"
            })

    for idx, star_key in enumerate(star_keys):
        if idx not in matched_star_indices and star_key_used_count[star_key] == 0:
            unmatched.append({
                "ALGO Key": "<No Match>",
                "STAR Key": star_key,
                "Status": "Mismatch - No ALGO Match"
            })

    matched_df = pd.DataFrame(matched)
    unmatched_df = pd.DataFrame(unmatched)

    summary = (
        f"Matched Records: {len(matched_df)}\n"
        f"Unmatched Records: {len(unmatched_df)}\n"
        f"Excluded Records: {len(excluded_df)}"
    )

    return excluded_df, matched_df, unmatched_df, summary

# Gradio UI
with gr.Blocks() as demo:
    gr.Markdown("## Reconciliation App with Exclusion and Overmatch Handling")

    algo_df_state = gr.State(pd.DataFrame())
    star_df_state = gr.State(pd.DataFrame())

    with gr.Row():
        algo_file = gr.File(label="Upload ALGO CSV")
        star_file = gr.File(label="Upload STAR CSV")

    with gr.Row():
        file_selector = gr.Dropdown(["ALGO", "STAR"], label="Select File for Exclusion Rule")
        column_selector = gr.Dropdown(label="Column Name")
        operator_input = gr.Dropdown(["=", "!="], label="Operator")
        value_input = gr.Textbox(label="Value (comma-separated)")

    run_btn = gr.Button("Run Reconciliation")

    excluded_out = gr.Dataframe(label="Excluded Records")
    matched_out = gr.Dataframe(label="Matched Records")
    unmatched_out = gr.Dataframe(label="Unmatched Records")
    summary_out = gr.Textbox(label="Summary")

    algo_file.change(fn=load_algo_file, inputs=algo_file, outputs=[algo_df_state, column_selector])
    star_file.change(fn=load_star_file, inputs=star_file, outputs=[star_df_state, column_selector])
    file_selector.change(update_column_dropdown,
                         inputs=[file_selector, algo_df_state, star_df_state],
                         outputs=column_selector)

    run_btn.click(
        reconcile_with_exclusion,
        inputs=[algo_df_state, star_df_state, file_selector, column_selector, operator_input, value_input],
        outputs=[excluded_out, matched_out, unmatched_out, summary_out]
    )

demo.launch()




..............




import oracledb
import pandas as pd
from collections import defaultdict

# Oracle DB connection
dsn = oracledb.makedsn("eurvlid25121.xmp.neLintra", 1521, service_name="358fr305")
conn = oracledb.connect(user="RAIDBA", password="1#Socrates UATDb Refresh#0", dsn=dsn)
cursor = conn.cursor()

# Load ALGO and STAR data
df_algo = pd.read_sql("SELECT * FROM INITIAL_MARGIN_EODNEW_DATA", conn)
df_star = pd.read_sql("SELECT * FROM STARALGONEW_DATA", conn)

# Ask user where to apply exclusion
file_type = input("Apply exclusion rule to (ALGO/STAR): ").strip().upper()
column = input("Enter column name for exclusion: ").strip()
operator = input("Enter operator (= or !=): ").strip()
value = input("Enter comma-separated value(s): ").strip()
values = [v.strip() for v in value.split(",")]

excluded_df = pd.DataFrame()

# Apply exclusion
if file_type == "ALGO" and column in df_algo.columns:
    if operator == "=":
        excluded_df = df_algo[df_algo[column].astype(str).isin(values)]
        df_algo = df_algo[~df_algo[column].astype(str).isin(values)]
    elif operator == "!=":
        excluded_df = df_algo[~df_algo[column].astype(str).isin(values)]
        df_algo = df_algo[df_algo[column].astype(str).isin(values)]
elif file_type == "STAR" and column in df_star.columns:
    if operator == "=":
        excluded_df = df_star[df_star[column].astype(str).isin(values)]
        df_star = df_star[~df_star[column].astype(str).isin(values)]
    elif operator == "!=":
        excluded_df = df_star[~df_star[column].astype(str).isin(values)]
        df_star = df_star[df_star[column].astype(str).isin(values)]
else:
    print("Invalid file or column name.")
    exit()

# Extract keys
algo_keys = df_algo['AGREEMENT_NAME'].astype(str).apply(
    lambda x: x.replace('_RIMR', '3CR').replace('_RIMP', '3CP').replace(" ", "")
).tolist()

star_keys = df_star.apply(
    lambda row: str(row.get('CRDS PARTY CODE', '')).strip().replace(" ", "") + 
                "3" + str(row.get('POST DIRECTION', '')).strip().replace(" ", ""),
    axis=1
).tolist()

# Reconciliation logic
matched, unmatched = [], []
star_key_map = defaultdict(list)

for idx, key in enumerate(star_keys):
    star_key_map[key].append(idx)

matched_star_indices = set()
star_key_used_count = defaultdict(int)

for i, algo_key in enumerate(algo_keys):
    match_idxs = star_key_map.get(algo_key, [])
    if len(match_idxs) == 1 and match_idxs[0] not in matched_star_indices:
        matched.append({
            "ALGO_KEY": algo_key,
            "STAR_KEY": star_keys[match_idxs[0]],
            "STATUS": "Match"
        })
        matched_star_indices.add(match_idxs[0])
        star_key_used_count[star_keys[match_idxs[0]]] += 1
    elif len(match_idxs) > 1:
        unmatched.append({
            "ALGO_KEY": algo_key,
            "STAR_KEY": "<Multiple STAR Match>",
            "STATUS": "Mismatch - Multiple STAR Keys"
        })
        for idx in match_idxs:
            unmatched.append({
                "ALGO_KEY": "<No Match>",
                "STAR_KEY": star_keys[idx],
                "STATUS": "Mismatch - STAR Key in Multiple Match"
            })
        for idx in match_idxs:
            star_key_used_count[star_keys[idx]] += 1
    else:
        unmatched.append({
            "ALGO_KEY": algo_key,
            "STAR_KEY": "<No Match>",
            "STATUS": "Mismatch - No STAR Match"
        })

for idx, star_key in enumerate(star_keys):
    if idx not in matched_star_indices and star_key_used_count[star_key] == 0:
        unmatched.append({
            "ALGO_KEY": "<No Match>",
            "STAR_KEY": star_key,
            "STATUS": "Mismatch - No ALGO Match"
        })

matched_df = pd.DataFrame(matched)
unmatched_df = pd.DataFrame(unmatched)

# Write to Oracle DB
def write_to_oracle(df, table_name):
    try:
        cursor.execute(f"BEGIN EXECUTE IMMEDIATE 'DROP TABLE {table_name}'; EXCEPTION WHEN OTHERS THEN NULL; END;")
        col_defs = ', '.join([f'"{col}" VARCHAR2(4000)' for col in df.columns])
        cursor.execute(f'CREATE TABLE {table_name} ({col_defs})')
        for _, row in df.iterrows():
            values = [str(val) if val is not None else None for val in row]
            placeholders = ','.join([':{}'.format(i+1) for i in range(len(values))])
            cursor.execute(f'INSERT INTO {table_name} VALUES ({placeholders})', values)
        conn.commit()
    except Exception as e:
        print(f"Error writing to {table_name}: {e}")

# Define output table names
matched_table = "IM_STAR_MATCHED_RECORDS"
unmatched_table = "IM_STAR_UNMATCHED_RECORDS"
excluded_table = "IM_STAR_EXCLUDED_RECORDS"

# Write results
write_to_oracle(matched_df, matched_table)
write_to_oracle(unmatched_df, unmatched_table)
if not excluded_df.empty:
    write_to_oracle(excluded_df, excluded_table)

print("\nReconciliation completed.")
print(f"Matched records saved to: {matched_table}")
print(f"Unmatched records saved to: {unmatched_table}")
print(f"Excluded records saved to: {excluded_table if not excluded_df.empty else 'None'}")

cursor.close()
conn.close()
