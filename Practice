import pandas as pd
import gradio as gr
from collections import defaultdict

# Helper functions
def extract_algo_keys(df):
    return df['Agreement_name'].astype(str).apply(
        lambda x: x.replace('_RIMR', '3CR')
                  .replace('_RIMP', '3CP')
                  .replace(" ", "")
                  .strip()
    ).tolist()

def extract_star_keys(df):
    return df.apply(
        lambda row: (str(row['CRDS Party Code']).strip().replace(" ", "") +
                     "3" +
                     str(row['Post Direction']).strip().replace(" ", "")),
        axis=1
    ).tolist()

# File loading
def load_algo_file(file):
    if file is None:
        return pd.DataFrame(), gr.update(choices=[])
    df = pd.read_csv(file).astype(str)
    return df, gr.update(choices=list(df.columns))

def load_star_file(file):
    if file is None:
        return pd.DataFrame(), gr.update(choices=[])
    df = pd.read_csv(file).astype(str)
    return df, gr.update(choices=list(df.columns))

# Dropdown updater
def update_column_dropdown(file_type, algo_df, star_df):
    if file_type == "ALGO":
        return gr.update(choices=list(algo_df.columns))
    elif file_type == "STAR":
        return gr.update(choices=list(star_df.columns))
    return gr.update(choices=[])

# Reconciliation logic with exclusion and overmatch handling
def reconcile_with_rule(algo_df, star_df, file_type, column, operator, value):
    df_algo = algo_df.copy()
    df_star = star_df.copy()
    excluded_df = pd.DataFrame()

    values = [v.strip() for v in value.split(',') if v.strip()]  # Support multiple values

    if file_type == "ALGO" and column in df_algo.columns:
        if operator == "=":
            excluded_df = df_algo[df_algo[column].isin(values)]
            df_algo = df_algo[~df_algo[column].isin(values)]
        else:
            excluded_df = df_algo[~df_algo[column].isin(values)]
            df_algo = df_algo[df_algo[column].isin(values)]
    elif file_type == "STAR" and column in df_star.columns:
        if operator == "=":
            excluded_df = df_star[df_star[column].isin(values)]
            df_star = df_star[~df_star[column].isin(values)]
        else:
            excluded_df = df_star[~df_star[column].isin(values)]
            df_star = df_star[df_star[column].isin(values)]

    algo_keys = extract_algo_keys(df_algo)
    star_keys = extract_star_keys(df_star)

    matched = []
    unmatched = []

    star_key_map = defaultdict(list)
    for idx, key in enumerate(star_keys):
        star_key_map[key].append(idx)

    matched_star_indices = set()

    for i, algo_key in enumerate(algo_keys):
        matching_star_idxs = star_key_map.get(algo_key, [])
        if len(matching_star_idxs) == 1:
            matched.append({
                "ALGO Key": algo_key,
                "STAR Key": star_keys[matching_star_idxs[0]],
                "Status": "Match"
            })
            matched_star_indices.add(matching_star_idxs[0])
        elif len(matching_star_idxs) > 1:
            for idx in matching_star_idxs:
                unmatched.append({
                    "ALGO Key": algo_key if i == 0 else "",
                    "STAR Key": star_keys[idx],
                    "Status": "Mismatch - Multiple STAR Keys"
                })
        else:
            unmatched.append({
                "ALGO Key": algo_key,
                "STAR Key": "<No Match>",
                "Status": "Mismatch - No Match"
            })

    for idx, star_key in enumerate(star_keys):
        if idx not in matched_star_indices:
            match_found = any(algo_key == star_key for algo_key in algo_keys)
            if not match_found or len(star_key_map[star_key]) > 1:
                unmatched.append({
                    "ALGO Key": "",
                    "STAR Key": star_key,
                    "Status": "Mismatch - No Match or Duplicate"
                })

    matched_df = pd.DataFrame(matched)
    unmatched_df = pd.DataFrame(unmatched)

    summary = (
        f"Matched Records: {len(matched_df)}\n"
        f"Unmatched Records: {len(unmatched_df)}\n"
        f"Excluded Records: {len(excluded_df)}"
    )

    return excluded_df, matched_df, unmatched_df, summary

# Gradio UI
with gr.Blocks() as demo:
    gr.Markdown("## Reconciliation App with Exclusion Rule and Overmatch Handling")

    algo_df_state = gr.State(pd.DataFrame())
    star_df_state = gr.State(pd.DataFrame())

    with gr.Row():
        algo_file = gr.File(label="Upload ALGO CSV")
        star_file = gr.File(label="Upload STAR CSV")

    with gr.Row():
        file_selector = gr.Dropdown(["ALGO", "STAR"], label="Select File for Rule")
        column_selector = gr.Dropdown(label="Column Name")
        operator_input = gr.Dropdown(["=", "!="], label="Operator")
        value_input = gr.Textbox(label="Value (comma-separated for multiple)")

    run_btn = gr.Button("Run Reconciliation")

    excluded_out = gr.Dataframe(label="Excluded Records")
    matched_out = gr.Dataframe(label="Matched Records")
    unmatched_out = gr.Dataframe(label="Unmatched Records")
    summary_out = gr.Textbox(label="Summary")

    algo_file.change(fn=load_algo_file, inputs=algo_file, outputs=[algo_df_state, column_selector])
    star_file.change(fn=load_star_file, inputs=star_file, outputs=[star_df_state, column_selector])
    file_selector.change(update_column_dropdown,
                         inputs=[file_selector, algo_df_state, star_df_state],
                         outputs=column_selector)

    run_btn.click(
        reconcile_with_rule,
        inputs=[algo_df_state, star_df_state, file_selector, column_selector, operator_input, value_input],
        outputs=[excluded_out, matched_out, unmatched_out, summary_out]
    )

demo.launch()




..........


import pandas as pd
import gradio as gr
from collections import defaultdict
import tempfile

def extract_algo_keys(df):
    return df['Agreement_name'].astype(str).apply(
        lambda x: x.replace('_RIMR', '3CR')
                  .replace('_RIMP', '3CP')
                  .replace(" ", "")
                  .strip()
    ).tolist()

def extract_star_keys(df):
    return df.apply(
        lambda row: (str(row['CRDS Party Code']).strip().replace(" ", "") +
                     "3" +
                     str(row['Post Direction']).strip().replace(" ", "")),
        axis=1
    ).tolist()

def reconcile_files(algo_file, star_file):
    df_algo = pd.read_csv(algo_file).astype(str)
    df_star = pd.read_csv(star_file).astype(str)

    algo_keys = extract_algo_keys(df_algo)
    star_keys = extract_star_keys(df_star)

    matched = []
    unmatched = []

    star_key_map = defaultdict(list)
    for idx, key in enumerate(star_keys):
        star_key_map[key].append(idx)

    matched_star_indices = set()
    matched_algo_indices = set()

    for i, algo_key in enumerate(algo_keys):
        matching_star_idxs = star_key_map.get(algo_key, [])
        if len(matching_star_idxs) == 1 and matching_star_idxs[0] not in matched_star_indices:
            matched.append({
                "ALGO Key": algo_key,
                "STAR Key": star_keys[matching_star_idxs[0]],
                "Status": "Match"
            })
            matched_star_indices.add(matching_star_idxs[0])
            matched_algo_indices.add(i)
        elif len(matching_star_idxs) > 1:
            for idx in matching_star_idxs:
                unmatched.append({
                    "ALGO Key": algo_key,
                    "STAR Key": star_keys[idx],
                    "Status": "Mismatch - Multiple STAR Keys"
                })
            matched_algo_indices.add(i)
        else:
            unmatched.append({
                "ALGO Key": algo_key,
                "STAR Key": "<No Match>",
                "Status": "Mismatch - No Match"
            })

    for idx, star_key in enumerate(star_keys):
        if idx not in matched_star_indices:
            match_found = any(algo_key == star_key for algo_key in algo_keys)
            if not match_found or len(star_key_map[star_key]) > 1:
                unmatched.append({
                    "ALGO Key": "<No Match>",
                    "STAR Key": star_key,
                    "Status": "Mismatch - No Match or Duplicate"
                })

    matched_df = pd.DataFrame(matched)
    unmatched_df = pd.DataFrame(unmatched)

    # Save to temp files
    matched_file = tempfile.NamedTemporaryFile(delete=False, suffix=".csv")
    unmatched_file = tempfile.NamedTemporaryFile(delete=False, suffix=".csv")
    matched_df.to_csv(matched_file.name, index=False)
    unmatched_df.to_csv(unmatched_file.name, index=False)

    summary = (
        f"Matched Records: {len(matched_df)}\n"
        f"Unmatched Records: {len(unmatched_df)}"
    )

    return matched_file.name, unmatched_file.name, summary

# Gradio Interface with file downloads
demo = gr.Interface(
    fn=reconcile_files,
    inputs=[
        gr.File(label="Upload ALGO CSV File"),
        gr.File(label="Upload STAR CSV File")
    ],
    outputs=[
        gr.File(label="Download Matched Records"),
        gr.File(label="Download Unmatched Records"),
        gr.Textbox(label="Summary")
    ],
    title="Reconciliation App - Download Matched/Unmatched as CSV",
    description="If multiple STAR keys match the same ALGO key, all are moved to the unmatched table. Results can be downloaded."
)

demo.launch()



....................



import pandas as pd
import gradio as gr
from collections import defaultdict

def extract_algo_keys(df):
    return df['Agreement_name'].astype(str).apply(
        lambda x: x.replace('_RIMR', '3CR')
                  .replace('_RIMP', '3CP')
                  .replace(" ", "")
                  .strip()
    ).tolist()

def extract_star_keys(df):
    return df.apply(
        lambda row: (str(row['CRDS Party Code']).strip().replace(" ", "") +
                     "3" +
                     str(row['Post Direction']).strip().replace(" ", "")),
        axis=1
    ).tolist()

def reconcile_files(algo_file, star_file):
    df_algo = pd.read_csv(algo_file).astype(str)
    df_star = pd.read_csv(star_file).astype(str)

    algo_keys = extract_algo_keys(df_algo)
    star_keys = extract_star_keys(df_star)

    matched = []
    unmatched = []

    # STAR key to indexes
    star_key_map = defaultdict(list)
    for idx, key in enumerate(star_keys):
        star_key_map[key].append(idx)

    matched_star_indices = set()
    matched_algo_indices = set()
    star_key_used_count = defaultdict(int)

    for i, algo_key in enumerate(algo_keys):
        matching_star_idxs = star_key_map.get(algo_key, [])
        if len(matching_star_idxs) == 1 and matching_star_idxs[0] not in matched_star_indices:
            matched.append({
                "ALGO Key": algo_key,
                "STAR Key": star_keys[matching_star_idxs[0]],
                "Status": "Match"
            })
            matched_star_indices.add(matching_star_idxs[0])
            matched_algo_indices.add(i)
            star_key_used_count[star_keys[matching_star_idxs[0]]] += 1
        elif len(matching_star_idxs) > 1:
            # Add ALGO key once per appearance in ALGO file
            unmatched.append({
                "ALGO Key": algo_key,
                "STAR Key": "<Multiple STAR Match>",
                "Status": "Mismatch - Multiple STAR Keys"
            })
            # All matching STAR keys go to unmatched
            for idx in matching_star_idxs:
                unmatched.append({
                    "ALGO Key": "<No Match>",
                    "STAR Key": star_keys[idx],
                    "Status": "Mismatch - STAR Key in Multiple Match"
                })
            matched_algo_indices.add(i)
            for idx in matching_star_idxs:
                star_key_used_count[star_keys[idx]] += 1
        else:
            unmatched.append({
                "ALGO Key": algo_key,
                "STAR Key": "<No Match>",
                "Status": "Mismatch - No STAR Match"
            })

    # STAR keys that weren't matched at all
    for idx, star_key in enumerate(star_keys):
        if idx not in matched_star_indices and star_key_used_count[star_key] == 0:
            unmatched.append({
                "ALGO Key": "<No Match>",
                "STAR Key": star_key,
                "Status": "Mismatch - No ALGO Match"
            })

    matched_df = pd.DataFrame(matched)
    unmatched_df = pd.DataFrame(unmatched)

    summary = (
        f"Matched Records: {len(matched_df)}\n"
        f"Unmatched Records: {len(unmatched_df)}"
    )

    return matched_df, unmatched_df, summary

# Gradio Interface
demo = gr.Interface(
    fn=reconcile_files,
    inputs=[
        gr.File(label="Upload ALGO CSV File"),
        gr.File(label="Upload STAR CSV File")
    ],
    outputs=[
        gr.Dataframe(label="Matched Records"),
        gr.Dataframe(label="Unmatched Records"),
        gr.Textbox(label="Summary")
    ],
    title="Reconciliation App with Smart STAR Overmatch Handling",
    description="Avoids duplicate ALGO keys in unmatched. Each STAR key still appears based on actual count."
)

demo.launch()



dope shope ###

import pandas as pd
import gradio as gr
from collections import defaultdict

# Helper functions
def extract_algo_keys(df):
    return df['Agreement_name'].astype(str).apply(
        lambda x: x.replace('_RIMR', '3CR')
                  .replace('_RIMP', '3CP')
                  .replace(" ", "")
                  .strip()
    ).tolist()

def extract_star_keys(df):
    return df.apply(
        lambda row: (str(row.get('CRDS Party Code', '')).strip().replace(" ", "") +
                     "3" +
                     str(row.get('Post Direction', '')).strip().replace(" ", "")),
        axis=1
    ).tolist()

# Loaders
def load_algo_file(file):
    try:
        df = pd.read_csv(file).astype(str)
        return df, gr.update(choices=list(df.columns))
    except Exception as e:
        return pd.DataFrame(), gr.update(choices=[])

def load_star_file(file):
    try:
        df = pd.read_csv(file).astype(str)
        return df, gr.update(choices=list(df.columns))
    except Exception as e:
        return pd.DataFrame(), gr.update(choices=[])

# Column dropdown update
def update_column_dropdown(file_type, algo_df, star_df):
    if file_type == "ALGO":
        return gr.update(choices=list(algo_df.columns))
    elif file_type == "STAR":
        return gr.update(choices=list(star_df.columns))
    return gr.update(choices=[])

# Reconciliation logic
def reconcile_with_exclusion(algo_df, star_df, file_type, column, operator, value):
    df_algo = algo_df.copy()
    df_star = star_df.copy()
    excluded_df = pd.DataFrame()

    values = [v.strip() for v in value.split(',') if v.strip()]

    if file_type == "ALGO" and column in df_algo.columns:
        if operator == "=":
            excluded_df = df_algo[df_algo[column].isin(values)]
            df_algo = df_algo[~df_algo[column].isin(values)]
        else:
            excluded_df = df_algo[~df_algo[column].isin(values)]
            df_algo = df_algo[df_algo[column].isin(values)]

    elif file_type == "STAR" and column in df_star.columns:
        if operator == "=":
            excluded_df = df_star[df_star[column].isin(values)]
            df_star = df_star[~df_star[column].isin(values)]
        else:
            excluded_df = df_star[~df_star[column].isin(values)]
            df_star = df_star[df_star[column].isin(values)]

    algo_keys = extract_algo_keys(df_algo)
    star_keys = extract_star_keys(df_star)

    matched = []
    unmatched = []

    star_key_map = defaultdict(list)
    for idx, key in enumerate(star_keys):
        star_key_map[key].append(idx)

    matched_star_indices = set()
    matched_algo_indices = set()
    star_key_used_count = defaultdict(int)

    for i, algo_key in enumerate(algo_keys):
        matching_star_idxs = star_key_map.get(algo_key, [])
        if len(matching_star_idxs) == 1 and matching_star_idxs[0] not in matched_star_indices:
            matched.append({
                "ALGO Key": algo_key,
                "STAR Key": star_keys[matching_star_idxs[0]],
                "Status": "Match"
            })
            matched_star_indices.add(matching_star_idxs[0])
            matched_algo_indices.add(i)
            star_key_used_count[star_keys[matching_star_idxs[0]]] += 1
        elif len(matching_star_idxs) > 1:
            unmatched.append({
                "ALGO Key": algo_key,
                "STAR Key": "<Multiple STAR Match>",
                "Status": "Mismatch - Multiple STAR Keys"
            })
            for idx in matching_star_idxs:
                unmatched.append({
                    "ALGO Key": "<No Match>",
                    "STAR Key": star_keys[idx],
                    "Status": "Mismatch - STAR Key in Multiple Match"
                })
            matched_algo_indices.add(i)
            for idx in matching_star_idxs:
                star_key_used_count[star_keys[idx]] += 1
        else:
            unmatched.append({
                "ALGO Key": algo_key,
                "STAR Key": "<No Match>",
                "Status": "Mismatch - No STAR Match"
            })

    for idx, star_key in enumerate(star_keys):
        if idx not in matched_star_indices and star_key_used_count[star_key] == 0:
            unmatched.append({
                "ALGO Key": "<No Match>",
                "STAR Key": star_key,
                "Status": "Mismatch - No ALGO Match"
            })

    matched_df = pd.DataFrame(matched)
    unmatched_df = pd.DataFrame(unmatched)

    summary = (
        f"Matched Records: {len(matched_df)}\n"
        f"Unmatched Records: {len(unmatched_df)}\n"
        f"Excluded Records: {len(excluded_df)}"
    )

    return excluded_df, matched_df, unmatched_df, summary

# Gradio UI
with gr.Blocks() as demo:
    gr.Markdown("## Reconciliation App with Exclusion and Overmatch Handling")

    algo_df_state = gr.State(pd.DataFrame())
    star_df_state = gr.State(pd.DataFrame())

    with gr.Row():
        algo_file = gr.File(label="Upload ALGO CSV")
        star_file = gr.File(label="Upload STAR CSV")

    with gr.Row():
        file_selector = gr.Dropdown(["ALGO", "STAR"], label="Select File for Exclusion Rule")
        column_selector = gr.Dropdown(label="Column Name")
        operator_input = gr.Dropdown(["=", "!="], label="Operator")
        value_input = gr.Textbox(label="Value (comma-separated)")

    run_btn = gr.Button("Run Reconciliation")

    excluded_out = gr.Dataframe(label="Excluded Records")
    matched_out = gr.Dataframe(label="Matched Records")
    unmatched_out = gr.Dataframe(label="Unmatched Records")
    summary_out = gr.Textbox(label="Summary")

    algo_file.change(fn=load_algo_file, inputs=algo_file, outputs=[algo_df_state, column_selector])
    star_file.change(fn=load_star_file, inputs=star_file, outputs=[star_df_state, column_selector])
    file_selector.change(update_column_dropdown,
                         inputs=[file_selector, algo_df_state, star_df_state],
                         outputs=column_selector)

    run_btn.click(
        reconcile_with_exclusion,
        inputs=[algo_df_state, star_df_state, file_selector, column_selector, operator_input, value_input],
        outputs=[excluded_out, matched_out, unmatched_out, summary_out]
    )

demo.launch()






............................


spring boot ðŸ«µðŸ«µðŸ«µ


pom.xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>com.oracle.database.jdbc</groupId>
        <artifactId>ojdbc8</artifactId>
        <version>19.8.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
</dependencies>





application.properties

spring.datasource.url=jdbc:oracle:thin:@//localhost:1521/358fr305
spring.datasource.username=RAIDBA
spring.datasource.password=1#Socrates*UATDb Refresh#0
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true





ExclusionRecord.java

import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class ExclusionRecord {
    @Id
    private Long id;
    private String algoKey;
    private String starKey;
    private String status;

    // getters and setters
}






MatchedRecord.java

import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class MatchedRecord {
    @Id
    private Long id;
    private String algoKey;
    private String starKey;
    private String status;

    // getters and setters
}





UnmatchedRecord.java

import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class UnmatchedRecord {
    @Id
    private Long id;
    private String algoKey;
    private String starKey;
    private String status;

    // getters and setters
}






ReconciliationService.java

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;

@Service
public class ReconciliationService {

    @Autowired
    private ExclusionRecordRepository exclusionRecordRepository;

    @Autowired
    private MatchedRecordRepository matchedRecordRepository;

    @Autowired
    private UnmatchedRecordRepository unmatchedRecordRepository;

    @Autowired
    private DatabaseRepository databaseRepository; // Fetches ALGO and STAR data

    @Transactional
    public String reconcile() {
        // Fetch data from DB
        List<Map<String, String>> algoData = databaseRepository.fetchAlgoData();
        List<Map<String, String>> starData = databaseRepository.fetchStarData();

        // Apply exclusion logic
        List<ExclusionRecord> exclusionRecords = applyExclusionRules(algoData, starData);

        // Reconciliation logic
        List<MatchedRecord> matchedRecords = new ArrayList<>();
        List<UnmatchedRecord> unmatchedRecords = new ArrayList<>();

        Map<String, List<Integer>> starKeyMap = new HashMap<>();
        for (int i = 0; i < starData.size(); i++) {
            String starKey = extractStarKey(starData.get(i));
            starKeyMap.computeIfAbsent(starKey, k -> new ArrayList<>()).add(i);
        }

        for (int i = 0; i < algoData.size(); i++) {
            String algoKey = extractAlgoKey(algoData.get(i));
            List<Integer> matchingStarIndices = starKeyMap.get(algoKey);
            if (matchingStarIndices != null && matchingStarIndices.size() == 1) {
                String starKey = extractStarKey(starData.get(matchingStarIndices.get(0)));
                matchedRecords.add(new MatchedRecord(null, algoKey, starKey, "Match"));
            } else if (matchingStarIndices != null && matchingStarIndices.size() > 1) {
                for (Integer idx : matchingStarIndices) {
                    unmatchedRecords.add(new UnmatchedRecord(null, algoKey, extractStarKey(starData.get(idx)), "Mismatch - Multiple STAR Keys"));
                }
            } else {
                unmatchedRecords.add(new UnmatchedRecord(null, algoKey, "<No Match>", "Mismatch - No Match"));
            }
        }

        // Store matched and unmatched records in the DB
        matchedRecordRepository.saveAll(matchedRecords);
        unmatchedRecordRepository.saveAll(unmatchedRecords);
        exclusionRecordRepository.saveAll(exclusionRecords);

        return "Reconciliation complete!";
    }

    private List<ExclusionRecord> applyExclusionRules(List<Map<String, String>> algoData, List<Map<String, String>> starData) {
        // Fetch exclusion rules from DB
        List<ExclusionRule> exclusionRules = exclusionRecordRepository.findAll();

        List<ExclusionRecord> exclusionRecords = new ArrayList<>();
        for (ExclusionRule rule : exclusionRules) {
            // Apply exclusion logic based on the rule
            // Filter and collect excluded records from both ALGO and STAR data
        }

        return exclusionRecords;
    }

    private String extractAlgoKey(Map<String, String> record) {
        String algoKey = record.get("Agreement_name").replace("_RIMR", "3CR").replace("_RIMP", "3CP").replace(" ", "").trim();
        return algoKey;
    }

    private String extractStarKey(Map<String, String> record) {
        String starKey = record.get("CRDS Party Code").replace(" ", "") + "3" + record.get("Post Direction").replace(" ", "");
        return starKey;
    }
}





ExclusionRecordRepository.java

import org.springframework.data.jpa.repository.JpaRepository;

public interface ExclusionRecordRepository extends JpaRepository<ExclusionRecord, Long> {
}





MatchedRecordRepository.java

import org.springframework.data.jpa.repository.JpaRepository;

public interface MatchedRecordRepository extends JpaRepository<MatchedRecord, Long> {
}






UnmatchedRecordRepository.java


import org.springframework.data.jpa.repository.JpaRepository;

public interface UnmatchedRecordRepository extends JpaRepository<UnmatchedRecord, Long> {
}






DatabaseRepository.java

import org.springframework.stereotype.Repository;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;
import java.util.Map;

@Repository
public class DatabaseRepository {

    private final JdbcTemplate jdbcTemplate;

    public DatabaseRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    public List<Map<String, String>> fetchAlgoData() {
        String query = "SELECT * FROM INITIAL_MARGIN_EODNEW_DATA";
        return jdbcTemplate.queryForList(query);
    }

    public List<Map<String, String>> fetchStarData() {
        String query = "SELECT * FROM STARALGONEW_DATA";
        return jdbcTemplate.queryForList(query);
    }
}






ReconciliationController.java

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ReconciliationController {

    @Autowired
    private ReconciliationService reconciliationService;

    @GetMapping("/reconcile")
    public String runReconciliation() {
        return reconciliationService.reconcile();
    }
}







ReconciliationApp.java

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ReconciliationApp {

    public static void main(String[] args) {
        SpringApplication.run(ReconciliationApp.class, args);
    }
}
                                
