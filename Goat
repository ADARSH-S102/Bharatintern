import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { TravelService } from '../services/travel';
import { DropdownService } from '../dropdown/dropdown';

type Travel = {
  uid: string;
  name: string;
  cluster: string;
  cluster1: string;
  origincity: string;
  destinationCity: string;
  startDate: string | Date;
  endDate: string | Date;
  travelclass: string;
  status?: 'Approved' | 'Rejected' | string;
};

@Component({
  selector: 'app-travel-details',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './travel-details.html',
  styleUrls: ['./travel-details.css']
})
export class TravelDetailsComponent implements OnInit {

  private travels: Travel[] = [];
  displayTravels: Travel[] = [];

  /* Status filter */
  selectedStatus: string = 'All';

  /* Cluster filter */
  clusters: string[] = [];
  filteredClusters: string[] = [];
  selectedCluster: string = '';

  constructor(
    private travelService: TravelService,
    private dropdownService: DropdownService
  ) {}

  ngOnInit(): void {
    this.travels = this.travelService.getTravels();
    this.displayTravels = [...this.travels];

    /* ‚úÖ SAME pattern as travell.ts */
    this.dropdownService.getOptions('cluster').subscribe({
      next: (data: string[]) => {
        this.clusters = Array.isArray(data) ? data : [];
        this.filteredClusters = [...this.clusters];
      },
      error: (err) => console.error('Failed to fetch cluster options', err)
    });
  }

  getStatusClass(status: string | undefined): string {
    if (status === 'Approved') return 'status-approved';
    if (status === 'Rejected') return 'status-rejected';
    return 'status-pending';
  }

  /* Type-ahead cluster search */
  onClusterSearch(): void {
    const value = this.selectedCluster.toLowerCase();
    this.filteredClusters = this.clusters.filter(c =>
      c.toLowerCase().includes(value)
    );
  }

  selectCluster(cluster: string): void {
    this.selectedCluster = cluster;
    this.filteredClusters = [];
  }

  /* Search button */
  applySearch(): void {
    this.displayTravels = this.travels.filter(t => {

      const statusMatch =
        this.selectedStatus === 'All' ||
        (t.status ?? 'Pending').toLowerCase() === this.selectedStatus.toLowerCase();

      const clusterMatch =
        !this.selectedCluster ||
        t.cluster.toLowerCase().includes(this.selectedCluster.toLowerCase());

      return statusMatch && clusterMatch;
    });
  }

  /* Reset button */
  resetFilters(): void {
    this.selectedStatus = 'All';
    this.selectedCluster = '';
    this.displayTravels = [...this.travels];
    this.filteredClusters = [...this.clusters];
  }
}


---

‚úÖ Updated travel-details.html (FILTER BAR + TABLE)

<div class="details-container">
  <h2>Travel Details</h2>

  <!-- FILTER BAR -->
  <div class="filter-bar">

    <!-- Status Filter -->
    <label>Show:</label>
    <select
      [(ngModel)]="selectedStatus"
      class="status-select">
      <option value="All">All</option>
      <option value="Approved">Approved</option>
      <option value="Rejected">Rejected</option>
      <option value="Pending">Pending</option>
    </select>

    <!-- Cluster Search -->
    <div class="cluster-search">
      <input
        type="text"
        placeholder="Search Cluster"
        [(ngModel)]="clusterSearch"
        (input)="onClusterTyping()" />

      <ul *ngIf="filteredClusters.length && clusterSearch">
        <li
          *ngFor="let c of filteredClusters"
          (click)="selectCluster(c)">
          {{ c }}
        </li>
      </ul>
    </div>

    <!-- Buttons -->
    <button class="btn search-btn" (click)="applySearch()">Search</button>
    <button class="btn reset-btn" (click)="resetFilters()">Reset</button>

  </div>

  <!-- TABLE -->
  <table class="travel-table" *ngIf="displayTravels.length; else noData">
    <thead>
      <tr>
        <th>UID</th>
        <th>Name</th>
        <th>Cluster</th>
        <th>Sub Cluster</th>
        <th>Origin City</th>
        <th>Destination City</th>
        <th>Start Date</th>
        <th>End Date</th>
        <th>Travel Class</th>
        <th>Status</th>
      </tr>
    </thead>

    <tbody>
      <tr *ngFor="let t of displayTravels">
        <td>{{ t.uid }}</td>
        <td>{{ t.name }}</td>
        <td>{{ t.cluster }}</td>
        <td>{{ t.cluster1 }}</td>
        <td>{{ t.origincity }}</td>
        <td>{{ t.destinationCity }}</td>
        <td>{{ t.startDate | date }}</td>
        <td>{{ t.endDate | date }}</td>
        <td>{{ t.travelclass }}</td>
        <td>
          <span [class]="getStatusClass(t.status)">
            {{ t.status || 'Pending' }}
          </span>
        </td>
      </tr>
    </tbody>
  </table>

  <ng-template #noData>
    <div class="no-data">No travel requests found.</div>
  </ng-template>
</div>


---

‚úÖ Minimal CSS Additions (append to existing CSS)

.cluster-search {
  position: relative;
}

.cluster-search input {
  padding: 8px 10px;
  border: 1px solid #cbd5e0;
  border-radius: 6px;
  min-width: 180px;
}

.cluster-search ul {
  position: absolute;
  background: #fff;
  border: 1px solid #ddd;
  width: 100%;
  max-height: 160px;
  overflow-y: auto;
  list-style: none;
  padding: 0;
  margin: 4px 0 0;
  z-index: 10;
}

.cluster-search li {
  padding: 8px 10px;
  cursor: pointer;
}

.cluster-search li:hover {
  background: #f1f5f9;
}

.btn {
  padding: 8px 14px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  font-weight: 600;
}

.search-btn {
  background: #008e5c;
  color: white;
}

.reset-btn {
  background: #e2e8f0;
}


---

‚úÖ What you now have (final clarity)

‚úî Cluster filter uses DropdownService
‚úî Type-ahead search while typing
‚úî Search button (explicit apply)
‚úî Reset button (clears everything)
‚úî Status filter still works exactly as before

If you want next:

auto-search without clicking Search

multi-cluster select

backend-driven filtering

pagination


Say the word ‚Äî we‚Äôll extend it cleanly üí™


















Got it üëç
I‚Äôll not change any existing behaviour, I‚Äôll only add a Cluster filter with typing/search support, and I‚Äôll send the full updated files so nothing breaks.

We will do this without backend calls (reuse the same data already loaded in travels, exactly like your form dropdown logic).


---

‚úÖ What this update does (clear & minimal)

Keeps Status filter (All / Approved / Rejected / Pending)

Adds Cluster filter

Cluster filter:

Loads values from existing travel data

While typing ‚Üí options auto-filter

User can select easily


No Origin / Destination filters (as you asked)

Table & status logic untouched



---

‚úÖ travel-details.html (FULL)

<div class="details-container">
  <h2>Travel Details</h2>

  <!-- FILTER BAR -->
  <div class="filter-bar">
    <label>Status:</label>
    <select
      [(ngModel)]="selectedStatus"
      (change)="applyFilter()"
      class="status-select"
    >
      <option value="All">All</option>
      <option value="Approved">Approved</option>
      <option value="Rejected">Rejected</option>
      <option value="Pending">Pending</option>
    </select>

    <label>Cluster:</label>
    <input
      type="text"
      class="status-select"
      placeholder="Type to search cluster"
      [(ngModel)]="clusterSearch"
      (input)="applyFilter()"
      list="clusterList"
    />

    <datalist id="clusterList">
      <option *ngFor="let c of uniqueClusters" [value]="c"></option>
    </datalist>
  </div>

  <!-- TABLE -->
  <table class="travel-table" *ngIf="displayTravels.length > 0; else noData">
    <thead>
      <tr>
        <th>UID</th>
        <th>Name</th>
        <th>Cluster</th>
        <th>Sub Cluster</th>
        <th>Origin City</th>
        <th>Destination City</th>
        <th>Start Date</th>
        <th>End Date</th>
        <th>Travel Class</th>
        <th>Status</th>
      </tr>
    </thead>

    <tbody>
      <tr *ngFor="let t of displayTravels">
        <td>{{ t.uid }}</td>
        <td>{{ t.name }}</td>
        <td>{{ t.cluster }}</td>
        <td>{{ t.cluster1 }}</td>
        <td>{{ t.origincity }}</td>
        <td>{{ t.destinationCity }}</td>
        <td>{{ t.startDate | date }}</td>
        <td>{{ t.endDate | date }}</td>
        <td>{{ t.travelclass }}</td>
        <td>
          <span [class]="getStatusClass(t.status)">
            {{ t.status || 'Pending' }}
          </span>
        </td>
      </tr>
    </tbody>
  </table>

  <ng-template #noData>
    <div class="no-data">
      No travel requests found for the selected filter.
    </div>
  </ng-template>
</div>


---

‚úÖ travel-details.ts (FULL & CLEAN)

import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { TravelService } from '../services/travel';

type Travel = {
  uid: string;
  name: string;
  cluster: string;
  cluster1: string;
  origincity: string;
  destinationCity: string;
  startDate: string | Date;
  endDate: string | Date;
  travelclass: string;
  status?: 'Approved' | 'Rejected' | 'Pending' | string;
};

@Component({
  selector: 'app-travel-details',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './travel-details.html',
  styleUrls: ['./travel-details.css']
})
export class TravelDetailsComponent implements OnInit {

  private travels: Travel[] = [];
  displayTravels: Travel[] = [];

  selectedStatus: string = 'All';
  clusterSearch: string = '';

  uniqueClusters: string[] = [];

  constructor(private travelService: TravelService) {}

  ngOnInit(): void {
    this.travels = this.travelService.getTravels();
    this.loadUniqueClusters();
    this.applyFilter();
  }

  loadUniqueClusters(): void {
    this.uniqueClusters = [
      ...new Set(this.travels.map(t => t.cluster).filter(Boolean))
    ];
  }

  applyFilter(): void {
    this.displayTravels = this.travels.filter(t => {

      const statusMatch =
        this.selectedStatus === 'All' ||
        (t.status ?? 'Pending').toLowerCase() === this.selectedStatus.toLowerCase();

      const clusterMatch =
        !this.clusterSearch ||
        t.cluster.toLowerCase().includes(this.clusterSearch.toLowerCase());

      return statusMatch && clusterMatch;
    });
  }

  getStatusClass(status: string | undefined): string {
    if (status === 'Approved') return 'status-approved';
    if (status === 'Rejected') return 'status-rejected';
    return 'status-pending';
  }
}


---

‚úÖ travel-details.css (ONLY FIXED & CLEANED)

.details-container {
  background: #fff;
  border-radius: 12px;
  padding: 40px 60px;
  margin: 70px auto;
  max-width: 1200px;
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1);
}

h2 {
  text-align: center;
  color: #008e5c;
  margin-bottom: 30px;
  font-weight: 700;
  font-size: 28px;
}

.filter-bar {
  display: flex;
  align-items: center;
  gap: 0.6rem;
  margin-bottom: 25px;
  flex-wrap: wrap;
}

.status-select {
  min-width: 150px;
  padding: 8px 12px;
  font-size: 0.95rem;
  font-family: "Poppins", sans-serif;
  border: 1px solid #cbd5e0;
  border-radius: 6px;
}

.travel-table {
  width: 100%;
  border-collapse: collapse;
  text-align: center;
  font-family: "Poppins", sans-serif;
}

.travel-table th,
.travel-table td {
  border-bottom: 1px solid #ddd;
  padding: 12px 10px;
  font-size: 15px;
}

.travel-table th {
  background-color: #008e5c;
  color: white;
}

.status-approved {
  background: #04a94e;
  color: white;
  padding: 5px 10px;
  border-radius: 6px;
  font-weight: 600;
}

.status-rejected {
  background: #d93025;
  color: white;
  padding: 5px 10px;
  border-radius: 6px;
  font-weight: 600;
}

.status-pending {
  background: #f6c90e;
  color: #333;
  padding: 5px 10px;
  border-radius: 6px;
  font-weight: 600;
}

.no-data {
  text-align: center;
  color: #888;
  font-style: italic;
  margin-top: 20px;
}


---

‚úÖ Result

‚úî Cluster filter works while typing

‚úî Dropdown suggestions auto-load

‚úî Status filter still works

‚úî No backend changes

‚úî No regression risk


If you want multi-select cluster, clear button, or server-side filtering, say the word ‚Äî we‚Äôll layer it cleanly.








