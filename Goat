import pandas as pd
import gradio as gr
from collections import defaultdict

# Global DataFrames
algo_df = pd.DataFrame()
star_df = pd.DataFrame()

def load_algo(file):
    global algo_df
    algo_df = pd.read_csv(file).astype(str)
    return gr.update(choices=algo_df.columns.tolist(), value=None)

def load_star(file):
    global star_df
    star_df = pd.read_csv(file).astype(str)
    return gr.update(choices=star_df.columns.tolist(), value=None)

def get_exclusion_columns(file_type):
    if file_type == "ALGO":
        return gr.update(choices=algo_df.columns.tolist(), value=None)
    elif file_type == "STAR":
        return gr.update(choices=star_df.columns.tolist(), value=None)
    return gr.update(choices=[], value=None)

def reconcile(algo_key_col, star_key_col, file_type, exclusion_col, operator, value, match_type):
    global algo_df, star_df
    if algo_df.empty or star_df.empty:
        return pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), "Missing file(s)"

    df_algo = algo_df.copy()
    df_star = star_df.copy()
    excluded_df = pd.DataFrame()

    # Apply exclusion
    values = [v.strip() for v in value.split(",") if v.strip()]
    if file_type == "ALGO" and exclusion_col in df_algo.columns:
        if operator == "=":
            excluded_df = df_algo[df_algo[exclusion_col].isin(values)]
            df_algo = df_algo[~df_algo[exclusion_col].isin(values)]
        else:
            excluded_df = df_algo[~df_algo[exclusion_col].isin(values)]
            df_algo = df_algo[df_algo[exclusion_col].isin(values)]
    elif file_type == "STAR" and exclusion_col in df_star.columns:
        if operator == "=":
            excluded_df = df_star[df_star[exclusion_col].isin(values)]
            df_star = df_star[~df_star[exclusion_col].isin(values)]
        else:
            excluded_df = df_star[~df_star[exclusion_col].isin(values)]
            df_star = df_star[df_star[exclusion_col].isin(values)]

    algo_keys = df_algo[algo_key_col].astype(str).str.strip().tolist()
    star_keys = df_star[star_key_col].astype(str).str.strip().tolist()

    matched = []
    unmatched = []

    # Build key-to-index mappings
    star_key_map = defaultdict(list)
    algo_key_map = defaultdict(list)
    for i, key in enumerate(star_keys):
        star_key_map[key].append(i)
    for i, key in enumerate(algo_keys):
        algo_key_map[key].append(i)

    matched_star = set()
    matched_algo = set()

    for algo_key, a_indices in algo_key_map.items():
        s_indices = star_key_map.get(algo_key, [])

        if match_type == "Strict One-to-One":
            if len(a_indices) == 1 and len(s_indices) == 1:
                matched.append({
                    "ALGO Key": algo_key,
                    "STAR Key": algo_key,
                    "Status": "Match 1-1"
                })
                matched_algo.update(a_indices)
                matched_star.update(s_indices)

        elif match_type == "One-to-Many":
            if len(a_indices) == 1 and len(s_indices) > 1:
                matched.append({
                    "ALGO Key": algo_key,
                    "STAR Key": f"{len(s_indices)} matches",
                    "Status": "Match 1-Many"
                })
                matched_algo.update(a_indices)
                matched_star.update(s_indices)

        elif match_type == "Many-to-One":
            if len(a_indices) > 1 and len(s_indices) == 1:
                matched.append({
                    "ALGO Key": f"{len(a_indices)} matches",
                    "STAR Key": algo_key,
                    "Status": "Match Many-1"
                })
                matched_algo.update(a_indices)
                matched_star.update(s_indices)

        elif match_type == "Many-to-Many":
            if len(a_indices) > 0 and len(s_indices) > 0:
                matched.append({
                    "ALGO Key": f"{len(a_indices)} match(es)",
                    "STAR Key": f"{len(s_indices)} match(es)",
                    "Status": "Match Many-Many"
                })
                matched_algo.update(a_indices)
                matched_star.update(s_indices)

    # Unmatched ALGO
    for i, key in enumerate(algo_keys):
        if i not in matched_algo:
            unmatched.append({"ALGO Key": key, "STAR Key": "<None>", "Status": "Unmatched ALGO"})

    # Unmatched STAR
    for i, key in enumerate(star_keys):
        if i not in matched_star:
            unmatched.append({"ALGO Key": "<None>", "STAR Key": key, "Status": "Unmatched STAR"})

    return pd.DataFrame(excluded_df), pd.DataFrame(matched), pd.DataFrame(unmatched), (
        f"Excluded: {len(excluded_df)}\nMatched: {len(matched)}\nUnmatched: {len(unmatched)}"
    )

with gr.Blocks() as demo:
    gr.Markdown("### File Reconciliation Tool with Matching Type")

    with gr.Row():
        algo_file = gr.File(label="Upload ALGO CSV")
        star_file = gr.File(label="Upload STAR CSV")

    with gr.Row():
        algo_key = gr.Dropdown(label="ALGO Key Column")
        star_key = gr.Dropdown(label="STAR Key Column")

    with gr.Row():
        file_type = gr.Dropdown(["ALGO", "STAR"], label="Apply Exclusion On")
        exclusion_column = gr.Dropdown(label="Column for Exclusion")
        operator = gr.Dropdown(["=", "!="], label="Operator")
        value = gr.Textbox(label="Value(s), comma-separated")

    match_type = gr.Dropdown(
        ["Strict One-to-One", "One-to-Many", "Many-to-One", "Many-to-Many"],
        label="Matching Type"
    )

    run = gr.Button("Reconcile")

    excluded_df = gr.Dataframe(label="Excluded")
    matched_df = gr.Dataframe(label="Matched")
    unmatched_df = gr.Dataframe(label="Unmatched")
    summary = gr.Textbox(label="Summary")

    algo_file.change(load_algo, inputs=algo_file, outputs=algo_key)
    star_file.change(load_star, inputs=star_file, outputs=star_key)
    file_type.change(get_exclusion_columns, inputs=file_type, outputs=exclusion_column)

    run.click(
        reconcile,
        inputs=[algo_key, star_key, file_type, exclusion_column, operator, value, match_type],
        outputs=[excluded_df, matched_df, unmatched_df, summary]
    )

demo.launch()























Here is the complete set of Java files in copy code format:


---

1. ReconciliationController.java

package com.example.demo.controller;

import com.example.demo.model.ReconciliationResult;
import com.example.demo.service.ReconciliationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/reconcile")
public class ReconciliationController {

    @Autowired
    private ReconciliationService reconciliationService;

    private final String algoPath = "C:\\Users\\59944\\OneDrive\\Desktop\\test\\Initial_Margin_800_28258387.csv";
    private final String starPath = "C:\\Users\\59944\\OneDrive\\Desktop\\test\\STARALGONEW_3428_20250387_1.csv";

    @GetMapping("/exclude")
    public ReconciliationResult exclude() {
        return reconciliationService.excludeAndTransform(algoPath, starPath);
    }

    @GetMapping("/nonexcluded")
    public ReconciliationResult getNonExcluded() {
        return reconciliationService.getNonExcluded();
    }

    @GetMapping("/match/{type}")
    public ReconciliationResult match(@PathVariable String type) {
        return reconciliationService.match(type);
    }
}


---

2. ReconciliationService.java

package com.example.demo.service;

import com.example.demo.model.Record;
import com.example.demo.model.ReconciliationResult;
import com.example.demo.util.CsvUtil;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class ReconciliationService {

    private List<Record> algoRecords = new ArrayList<>();
    private List<Record> starRecords = new ArrayList<>();
    private List<Record> excludedRecords = new ArrayList<>();
    private List<Record> nonExcludedAlgo = new ArrayList<>();
    private List<Record> nonExcludedStar = new ArrayList<>();

    public ReconciliationResult excludeAndTransform(String algoPath, String starPath) {
        algoRecords = CsvUtil.readCsv(algoPath);
        starRecords = CsvUtil.readCsv(starPath);

        excludedRecords = algoRecords.stream()
                .filter(r -> r.getAmount() == 0)
                .collect(Collectors.toList());

        nonExcludedAlgo = algoRecords.stream()
                .filter(r -> r.getAmount() != 0)
                .collect(Collectors.toList());

        nonExcludedStar = starRecords;

        return new ReconciliationResult(new ArrayList<>(), new ArrayList<>(), excludedRecords, nonExcludedAlgo.size(), nonExcludedStar.size());
    }

    public ReconciliationResult getNonExcluded() {
        return new ReconciliationResult(nonExcludedAlgo, nonExcludedStar, new ArrayList<>(), nonExcludedAlgo.size(), nonExcludedStar.size());
    }

    public ReconciliationResult match(String type) {
        List<Record> matched = new ArrayList<>();

        for (Record algo : nonExcludedAlgo) {
            for (Record star : nonExcludedStar) {
                if (algo.getKey().equals(star.getKey()) && algo.getAmount() == star.getAmount()) {
                    matched.add(algo);
                    break;
                }
            }
        }

        List<Record> unmatchedAlgo = nonExcludedAlgo.stream()
                .filter(r -> !matched.contains(r))
                .collect(Collectors.toList());

        return new ReconciliationResult(matched, unmatchedAlgo, excludedRecords, nonExcludedAlgo.size(), nonExcludedStar.size());
    }
}


---

3. ReconciliationResult.java

package com.example.demo.model;

import java.util.List;

public class ReconciliationResult {

    private List<Record> matched;
    private List<Record> unmatched;
    private List<Record> excluded;

    private int matchedCount;
    private int unmatchedCount;
    private int excludedCount;
    private int nonExcludedAlgoCount;
    private int nonExcludedStarCount;

    public ReconciliationResult(List<Record> matched, List<Record> unmatched, List<Record> excluded, int nonExcludedAlgoCount, int nonExcludedStarCount) {
        this.matched = matched;
        this.unmatched = unmatched;
        this.excluded = excluded;
        this.matchedCount = matched.size();
        this.unmatchedCount = unmatched.size();
        this.excludedCount = excluded.size();
        this.nonExcludedAlgoCount = nonExcludedAlgoCount;
        this.nonExcludedStarCount = nonExcludedStarCount;
    }

    public List<Record> getMatched() { return matched; }
    public List<Record> getUnmatched() { return unmatched; }
    public List<Record> getExcluded() { return excluded; }

    public int getMatchedCount() { return matchedCount; }
    public int getUnmatchedCount() { return unmatchedCount; }
    public int getExcludedCount() { return excludedCount; }
    public int getNonExcludedAlgoCount() { return nonExcludedAlgoCount; }
    public int getNonExcludedStarCount() { return nonExcludedStarCount; }
}


---

4. Record.java

package com.example.demo.model;

public class Record {

    private String key;
    private double amount;

    public Record() {}

    public Record(String key, double amount) {
        this.key = key;
        this.amount = amount;
    }

    public String getKey() { return key; }
    public void setKey(String key) { this.key = key; }

    public double getAmount() { return amount; }
    public void setAmount(double amount) { this.amount = amount; }
}


---

5. CsvUtil.java

package com.example.demo.util;

import com.example.demo.model.Record;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;

import java.io.FileReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;

public class CsvUtil {

    public static List<Record> readCsv(String filePath) {
        List<Record> records = new ArrayList<>();
        try {
            Reader in = new FileReader(filePath);
            Iterable<CSVRecord> csvRecords = CSVFormat.DEFAULT.withFirstRecordAsHeader().parse(in);
            for (CSVRecord record : csvRecords) {
                String key = record.get("Key");
                double amount = Double.parseDouble(record.get("Amount"));
                records.add(new Record(key, amount));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return records;
    }
}


---

Test on localhost

After starting the Spring Boot application, use these endpoints in your browser or Postman:

http://localhost:8080/reconcile/exclude – performs exclusion

http://localhost:8080/reconcile/nonexcluded – shows non-excluded ALGO and STAR with counts

http://localhost:8080/reconcile/match/1to1 – shows matched records and counts after exclusion


Let me know if you want to add DB integration or more matching rules.


                                                        nonExcludedAlgo.size(),
                
